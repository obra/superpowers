# Superpowers 技能学习指南

本文档整理了 Superpowers 项目中的所有技能（Skills），帮助你系统地学习和使用这些技能来提升 AI 辅助开发的效率和质量。

---

## 目录

1. [技能概述](#技能概述)
2. [核心技能分类](#核心技能分类)
3. [技能详解](#技能详解)
   - [using-superpowers](#1-using-superpowers-使用技能的基础)
   - [brainstorming](#2-brainstorming-头脑风暴)
   - [writing-plans](#3-writing-plans-编写计划)
   - [executing-plans](#4-executing-plans-执行计划)
   - [subagent-driven-development](#5-subagent-driven-development-子代理驱动开发)
   - [test-driven-development](#6-test-driven-development-测试驱动开发)
   - [systematic-debugging](#7-systematic-debugging-系统化调试)
   - [verification-before-completion](#8-verification-before-completion-完成前验证)
   - [requesting-code-review](#9-requesting-code-review-请求代码审查)
   - [receiving-code-review](#10-receiving-code-review-接收代码审查)
   - [finishing-a-development-branch](#11-finishing-a-development-branch-完成开发分支)
   - [using-git-worktrees](#12-using-git-worktrees-使用-git-worktrees)
   - [dispatching-parallel-agents](#13-dispatching-parallel-agents-并行调度代理)
   - [writing-skills](#14-writing-skills-编写技能)
4. [技能使用流程图](#技能使用流程图)
5. [快速参考表](#快速参考表)

---

## 技能概述

Superpowers 是一套专为 AI 辅助开发设计的技能系统。每个技能都是经过验证的最佳实践，帮助 AI 代理（如 Claude）更有效地完成开发任务。

**核心原则：**
- 技能必须被主动调用，不能跳过
- 即使只有 1% 的可能性适用，也应该调用技能检查
- 技能定义了"如何做"，用户指令定义了"做什么"

---

## 核心技能分类

| 类别 | 技能 | 用途 |
|------|------|------|
| **流程入口** | using-superpowers | 技能系统的使用指南 |
| **设计阶段** | brainstorming | 将想法转化为设计 |
| **计划阶段** | writing-plans | 编写实现计划 |
| **执行阶段** | executing-plans, subagent-driven-development | 执行计划 |
| **质量保证** | test-driven-development, systematic-debugging, verification-before-completion | 确保代码质量 |
| **代码审查** | requesting-code-review, receiving-code-review | 代码审查流程 |
| **分支管理** | finishing-a-development-branch, using-git-worktrees | Git 工作流 |
| **并行开发** | dispatching-parallel-agents | 多任务并行处理 |
| **扩展系统** | writing-skills | 创建新技能 |

---

## 技能详解

### 1. using-superpowers (使用技能的基础)

**描述：** 技能系统的入门指南，定义了如何正确使用技能。

**核心原则：**
- 在任何响应或操作之前，先调用相关技能
- 即使只有 1% 的可能性适用，也要调用技能
- 如果调用后发现不适用，可以不使用

**技能优先级：**
1. 先使用流程技能（brainstorming, debugging）- 确定如何处理任务
2. 再使用实现技能（frontend-design, mcp-builder）- 指导执行

**技能类型：**
- **严格型**（TDD, debugging）：必须严格遵循
- **灵活型**（patterns）：根据上下文调整

**常见错误想法（红旗）：**

| 错误想法 | 现实 |
|---------|------|
| "这只是一个简单问题" | 问题也是任务，检查技能 |
| "我需要先了解更多上下文" | 技能检查在提问之前 |
| "让我先探索代码库" | 技能告诉你如何探索 |
| "这不需要正式技能" | 如果技能存在，就使用它 |

---

### 2. brainstorming (头脑风暴)

**描述：** 在任何创意工作之前必须使用 - 创建功能、构建组件、添加功能或修改行为。

**使用时机：** 需要将想法转化为完整设计和规格时。

**核心流程：**

1. **理解想法**
   - 先检查当前项目状态（文件、文档、最近提交）
   - 一次问一个问题来细化想法
   - 尽可能使用选择题
   - 专注于理解：目的、约束、成功标准

2. **探索方案**
   - 提出 2-3 个不同的方案及其权衡
   - 以对话方式呈现选项，给出推荐和理由
   - 先说推荐选项并解释原因

3. **呈现设计**
   - 分成 200-300 字的小节
   - 每节后询问是否正确
   - 涵盖：架构、组件、数据流、错误处理、测试

**设计完成后：**
- 将设计写入 `docs/plans/YYYY-MM-DD-<topic>-design.md`
- 提交设计文档到 git
- 如果继续实现，使用 `using-git-worktrees` 创建隔离工作区

**关键原则：**
- 一次一个问题
- 尽可能用选择题
- 严格遵循 YAGNI（不要添加不需要的功能）
- 始终探索 2-3 个备选方案

---

### 3. writing-plans (编写计划)

**描述：** 当你有规格或需求要完成多步骤任务时，在编写代码之前使用。

**使用时机：** 有设计文档或需求后，在开始编码前。

**核心原则：** 
- 假设实现者对代码库零上下文
- 文档化他们需要知道的一切
- 每个步骤是一个动作（2-5分钟）

**计划文档头部格式：**
```markdown
# [功能名称] 实现计划

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans

**目标:** [一句话描述要构建什么]

**架构:** [2-3句话描述方法]

**技术栈:** [关键技术/库]

---
```

**任务结构示例：**
```markdown
### Task N: [组件名称]

**文件:**
- Create: `exact/path/to/file.py`
- Modify: `exact/path/to/existing.py:123-145`
- Test: `tests/exact/path/to/test.py`

**Step 1: 编写失败测试**
[代码]

**Step 2: 运行测试验证失败**
Run: `pytest tests/path/test.py::test_name -v`
Expected: FAIL

**Step 3: 编写最小实现**
[代码]

**Step 4: 运行测试验证通过**
Run: `pytest tests/path/test.py::test_name -v`
Expected: PASS

**Step 5: 提交**
```bash
git commit -m "feat: add specific feature"
```
```

**执行选择：**
1. **子代理驱动**（当前会话）- 每个任务调度新子代理，任务间审查
2. **并行会话**（单独会话）- 使用 executing-plans，批量执行

---

### 4. executing-plans (执行计划)

**描述：** 当你有书面实现计划需要在单独会话中执行时使用。

**使用时机：** 有写好的计划需要执行时，带有审查检查点。

**核心原则：** 批量执行 + 检查点让架构师审查

**流程：**

1. **加载和审查计划**
   - 读取计划文件
   - 批判性审查 - 识别问题或疑虑
   - 如有疑虑：开始前与人类伙伴提出
   - 如无疑虑：创建 TodoWrite 并继续

2. **执行批次**（默认：前3个任务）
   - 标记为进行中
   - 严格按步骤执行
   - 运行验证
   - 标记为完成

3. **报告**
   - 显示已实现内容
   - 显示验证输出
   - 说："Ready for feedback."

4. **继续**
   - 根据反馈应用更改
   - 执行下一批次

5. **完成开发**
   - 使用 `finishing-a-development-branch` 技能

**何时停止并寻求帮助：**
- 批次中遇到阻塞
- 计划有关键缺陷
- 不理解指令
- 验证反复失败

---

### 5. subagent-driven-development (子代理驱动开发)

**描述：** 在当前会话中执行具有独立任务的实现计划时使用。

**使用时机：** 
- 有实现计划
- 任务大多独立
- 想在当前会话中完成

**核心原则：** 每个任务使用新子代理 + 两阶段审查（规格合规 + 代码质量）

**流程：**

1. 读取计划，提取所有任务，创建 TodoWrite
2. 对每个任务：
   - 调度实现者子代理
   - 回答子代理问题
   - 子代理实现、测试、提交、自审查
   - 调度规格审查子代理
   - 调度代码质量审查子代理
   - 标记任务完成
3. 所有任务完成后：
   - 调度最终代码审查
   - 使用 `finishing-a-development-branch`

**与 executing-plans 的区别：**
- 同一会话（无上下文切换）
- 每个任务使用新子代理（无上下文污染）
- 两阶段审查
- 更快迭代

**红旗（绝对不要）：**
- 跳过审查
- 在未解决问题时继续
- 并行调度多个实现子代理（会冲突）
- 让子代理读取计划文件（直接提供完整文本）

---

### 6. test-driven-development (测试驱动开发)

**描述：** 在实现任何功能或修复bug时，在编写实现代码之前使用。

**铁律：**
```
没有失败测试，就不能写生产代码
```

**Red-Green-Refactor 循环：**

1. **RED - 编写失败测试**
   - 编写一个最小测试展示应该发生什么
   - 一个行为、清晰命名、使用真实代码

2. **验证 RED - 观察失败**
   - 运行测试
   - 确认失败（不是错误）
   - 确认失败信息符合预期

3. **GREEN - 最小代码**
   - 编写最简单的代码让测试通过
   - 不添加额外功能

4. **验证 GREEN - 观察通过**
   - 运行测试
   - 确认通过
   - 确认其他测试仍通过

5. **REFACTOR - 清理**
   - 仅在绿色之后
   - 移除重复、改进命名
   - 保持测试绿色

**为什么顺序重要：**
- 测试后写的代码会立即通过，证明不了什么
- 测试优先强迫你看到测试失败，证明它确实测试了某些东西

**常见借口与现实：**

| 借口 | 现实 |
|------|------|
| "太简单不需要测试" | 简单代码也会出错，测试只需30秒 |
| "我之后再测试" | 立即通过的测试证明不了什么 |
| "我已经手动测试过了" | 临时测试 ≠ 系统测试 |
| "删除X小时的工作太浪费" | 沉没成本谬误，保留无法信任的代码才是技术债务 |

---

### 7. systematic-debugging (系统化调试)

**描述：** 遇到任何bug、测试失败或意外行为时，在提出修复之前使用。

**铁律：**
```
没有先调查根本原因，就不能修复
```

**四个阶段：**

#### 阶段1：根本原因调查

1. **仔细阅读错误信息**
   - 不要跳过错误或警告
   - 完整阅读堆栈跟踪

2. **一致性复现**
   - 能可靠触发吗？
   - 确切步骤是什么？

3. **检查最近更改**
   - 什么更改可能导致这个？
   - Git diff，最近提交

4. **在多组件系统中收集证据**
   - 在每个组件边界添加诊断日志
   - 运行一次收集证据
   - 分析证据确定失败组件

5. **追踪数据流**
   - 坏值从哪里来？
   - 什么调用了这个坏值？
   - 继续向上追踪直到找到源头

#### 阶段2：模式分析

1. 找到工作示例
2. 与参考比较
3. 识别差异
4. 理解依赖

#### 阶段3：假设和测试

1. 形成单一假设
2. 最小化测试
3. 验证后再继续

#### 阶段4：实现

1. 创建失败测试用例
2. 实现单一修复
3. 验证修复
4. 如果3+次修复失败：质疑架构

**红旗（表示返回阶段1）：**
- "先快速修复，之后再调查"
- "试着改变X看看是否有效"
- "我不完全理解但这可能有效"

---

### 8. verification-before-completion (完成前验证)

**描述：** 在声称工作完成、修复或通过之前，在提交或创建PR之前使用。

**铁律：**
```
没有新鲜验证证据，就不能声称完成
```

**门控函数：**
```
在声称任何状态之前：

1. 识别：什么命令证明这个声明？
2. 运行：执行完整命令（新鲜、完整）
3. 阅读：完整输出，检查退出码，计数失败
4. 验证：输出是否确认声明？
   - 如果否：用证据陈述实际状态
   - 如果是：带证据陈述声明
5. 然后：做出声明
```

**常见失败：**

| 声明 | 需要 | 不够 |
|------|------|------|
| 测试通过 | 测试输出：0失败 | 之前的运行，"应该通过" |
| 构建成功 | 构建命令：exit 0 | lint通过，日志看起来好 |
| Bug已修复 | 测试原始症状：通过 | 代码改了，假设已修复 |
| 需求满足 | 逐行检查清单 | 测试通过 |

**红旗：**
- 使用"应该"、"可能"、"似乎"
- 验证前表达满意（"太好了！"、"完美！"、"完成！"）
- 没有验证就提交/推送/PR
- 信任代理成功报告

---

### 9. requesting-code-review (请求代码审查)

**描述：** 完成任务、实现主要功能或合并前验证工作时使用。

**何时请求审查：**

**强制：**
- 子代理驱动开发中每个任务之后
- 完成主要功能后
- 合并到主分支前

**可选但有价值：**
- 卡住时（新鲜视角）
- 重构前（基线检查）
- 修复复杂bug后

**如何请求：**

1. 获取 git SHAs：
   ```bash
   BASE_SHA=$(git rev-parse HEAD~1)
   HEAD_SHA=$(git rev-parse HEAD)
   ```

2. 调度 code-reviewer 子代理

3. 根据反馈行动：
   - Critical 问题立即修复
   - Important 问题继续前修复
   - Minor 问题稍后处理
   - 如果审查者错了，用理由反驳

---

### 10. receiving-code-review (接收代码审查)

**描述：** 收到代码审查反馈时，在实现建议之前使用，特别是反馈不清晰或技术上有疑问时。

**核心原则：** 验证后再实现。询问后再假设。技术正确性优于社交舒适。

**响应模式：**
```
收到代码审查反馈时：

1. 阅读：完整反馈，不反应
2. 理解：用自己的话重述需求（或询问）
3. 验证：对照代码库现实检查
4. 评估：对这个代码库技术上合理吗？
5. 响应：技术确认或有理由的反驳
6. 实现：一次一项，每项测试
```

**禁止的响应：**
- "你说得太对了！"
- "好观点！"
- "让我现在就实现"（验证前）

**何时反驳：**
- 建议破坏现有功能
- 审查者缺乏完整上下文
- 违反 YAGNI
- 对此技术栈不正确
- 与架构决策冲突

**确认正确反馈：**
```
✅ "已修复。[简要描述更改了什么]"
✅ "好发现 - [具体问题]。在[位置]修复了。"
❌ "你说得对！"
❌ "谢谢！"
```

---

### 11. finishing-a-development-branch (完成开发分支)

**描述：** 实现完成、所有测试通过、需要决定如何集成工作时使用。

**核心原则：** 验证测试 → 呈现选项 → 执行选择 → 清理

**流程：**

1. **验证测试**
   - 运行项目测试套件
   - 测试失败则停止

2. **确定基础分支**
   ```bash
   git merge-base HEAD main 2>/dev/null
   ```

3. **呈现选项**
   ```
   实现完成。你想做什么？

   1. 本地合并回 <base-branch>
   2. 推送并创建 Pull Request
   3. 保持分支现状（我稍后处理）
   4. 丢弃这个工作
   ```

4. **执行选择**

5. **清理 Worktree**
   - 选项1、4：移除 worktree
   - 选项2、3：保留 worktree

**选项快速参考：**

| 选项 | 合并 | 推送 | 保留Worktree | 清理分支 |
|------|------|------|--------------|----------|
| 1. 本地合并 | ✓ | - | - | ✓ |
| 2. 创建PR | - | ✓ | ✓ | - |
| 3. 保持现状 | - | - | ✓ | - |
| 4. 丢弃 | - | - | - | ✓ (force) |

---

### 12. using-git-worktrees (使用 Git Worktrees)

**描述：** 开始需要与当前工作区隔离的功能工作时，或执行实现计划前使用。

**核心原则：** 系统化目录选择 + 安全验证 = 可靠隔离

**目录选择优先级：**

1. 检查现有目录
   ```bash
   ls -d .worktrees 2>/dev/null
   ls -d worktrees 2>/dev/null
   ```

2. 检查 CLAUDE.md 中的偏好

3. 询问用户

**安全验证：**
- 对于项目本地目录，必须验证目录被 gitignore
- 如果未被忽略，添加到 .gitignore 并提交

**创建步骤：**

1. 检测项目名称
2. 创建 Worktree
   ```bash
   git worktree add "$path" -b "$BRANCH_NAME"
   ```
3. 运行项目设置（npm install 等）
4. 验证干净基线（运行测试）
5. 报告位置

**常见错误：**
- 跳过忽略验证
- 假设目录位置
- 测试失败时继续
- 硬编码设置命令

---

### 13. dispatching-parallel-agents (并行调度代理)

**描述：** 面对2+个独立任务，可以不共享状态或无顺序依赖时使用。

**核心原则：** 每个独立问题域调度一个代理，让它们并发工作。

**何时使用：**
- 3+ 个测试文件因不同根因失败
- 多个子系统独立损坏
- 每个问题可以不需要其他问题的上下文理解
- 调查之间无共享状态

**何时不使用：**
- 失败相关（修一个可能修复其他）
- 需要理解完整系统状态
- 代理会相互干扰

**模式：**

1. **识别独立域**
   - 按什么损坏分组失败

2. **创建聚焦的代理任务**
   - 具体范围：一个测试文件或子系统
   - 清晰目标：让这些测试通过
   - 约束：不改变其他代码
   - 预期输出：发现和修复的摘要

3. **并行调度**

4. **审查和集成**
   - 阅读每个摘要
   - 验证修复不冲突
   - 运行完整测试套件

**代理提示结构：**
```markdown
修复 src/agents/agent-tool-abort.test.ts 中的3个失败测试：

1. "should abort tool..." - 期望消息中有 'interrupted at'
2. "should handle mixed..." - 快速工具被中止而不是完成
3. "should properly track..." - 期望3个结果但得到0

这些是时序/竞态条件问题。你的任务：

1. 读取测试文件理解每个测试验证什么
2. 识别根因 - 时序问题还是实际bug？
3. 修复...

返回：发现和修复内容的摘要。
```

---

### 14. writing-skills (编写技能)

**描述：** 创建新技能、编辑现有技能或验证技能在部署前有效时使用。

**核心原则：** 编写技能 IS 测试驱动开发应用于流程文档。

**技能是什么：**
- 可重用技术、模式、工具、参考指南
- **不是**：关于你如何解决某个问题的叙述

**TDD 映射：**

| TDD 概念 | 技能创建 |
|---------|---------|
| 测试用例 | 带子代理的压力场景 |
| 生产代码 | 技能文档 (SKILL.md) |
| 测试失败 (RED) | 代理在无技能时违反规则 |
| 测试通过 (GREEN) | 代理在有技能时遵守 |
| 重构 | 关闭漏洞同时保持合规 |

**SKILL.md 结构：**
```markdown
---
name: skill-name-with-hyphens
description: Use when [specific triggering conditions]
---

# 技能名称

## Overview
什么是这个？1-2句核心原则。

## When to Use
症状和用例的项目符号列表

## Core Pattern
前后代码比较

## Quick Reference
扫描常见操作的表格

## Common Mistakes
什么出错 + 修复
```

**描述字段关键点：**
- 以 "Use when..." 开始
- 只描述触发条件
- **绝不**总结技能的流程或工作流

**铁律：**
```
没有失败测试，就不能写技能
```

---

## 技能使用流程图

```
                    ┌──────────────────┐
                    │ 收到用户消息     │
                    └────────┬─────────┘
                             │
                             ▼
                    ┌──────────────────┐
                    │ 可能有技能适用？ │
                    └────────┬─────────┘
                             │
              ┌──────────────┴──────────────┐
              │ 是（即使1%）                │ 否
              ▼                             ▼
    ┌─────────────────┐           ┌─────────────────┐
    │ 调用技能工具    │           │ 直接响应        │
    └────────┬────────┘           └─────────────────┘
             │
             ▼
    ┌─────────────────┐
    │ 宣布使用技能    │
    └────────┬────────┘
             │
             ▼
    ┌─────────────────┐
    │ 严格遵循技能    │
    └─────────────────┘
```

---

## 快速参考表

| 我想要... | 使用技能 |
|----------|---------|
| 将想法变成设计 | brainstorming |
| 创建实现计划 | writing-plans |
| 执行计划（分开会话） | executing-plans |
| 执行计划（当前会话） | subagent-driven-development |
| 写代码 | test-driven-development |
| 调试问题 | systematic-debugging |
| 确认工作完成 | verification-before-completion |
| 请求代码审查 | requesting-code-review |
| 处理审查反馈 | receiving-code-review |
| 完成分支工作 | finishing-a-development-branch |
| 创建隔离工作区 | using-git-worktrees |
| 并行解决多个问题 | dispatching-parallel-agents |
| 创建新技能 | writing-skills |

---

## 学习建议

1. **从 using-superpowers 开始** - 理解技能系统的基本原则
2. **掌握核心流程** - brainstorming → writing-plans → executing-plans
3. **内化质量技能** - test-driven-development, verification-before-completion
4. **按需学习其他技能** - 遇到具体场景时深入学习

**记住：** 技能是经过验证的最佳实践，即使感觉"可能不需要"，也应该先调用检查。
